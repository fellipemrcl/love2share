generator client {
  provider = "prisma-client-js"
  output   = "../src/app/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String                @id @default(uuid())
  clerkId               String                @unique
  email                 String                @unique
  name                  String?
  credits               Float                 @default(0)
  streamingGroupUsers   StreamingGroupUser[]
  ownedStreamingAccounts StreamingGroupStreaming[]
  createdGroups         StreamingGroup[]      @relation("GroupCreator")
  joinRequests          GroupJoinRequest[]
  respondedJoinRequests GroupJoinRequest[]    @relation("GroupJoinRequestResponder")
  creditTransactions    CreditTransaction[]
  paymentTransactions   PaymentTransaction[]
}

model StreamingGroup {
  id                    String                @id @default(uuid())
  name                  String
  description           String?
  maxMembers            Int                   @default(2)
  createdById           String
  createdBy             User                  @relation("GroupCreator", fields: [createdById], references: [id])
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  streamingGroupUsers   StreamingGroupUser[]
  streamingGroupStreamings StreamingGroupStreaming[]
  joinRequests          GroupJoinRequest[]
}

model StreamingGroupUser {
  id                    String         @id @default(uuid())
  streamingGroup        StreamingGroup @relation(fields: [streamingGroupId], references: [id])
  streamingGroupId      String
  user                  User           @relation(fields: [userId], references: [id])
  userId                String
  role                  StreamingGroupRole @default(MEMBER)
  accessDataStatus      AccessDataStatus @default(PENDING)
  accessDataSentAt      DateTime?
  accessDataConfirmedAt DateTime?
  accessDataDeadline    DateTime?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  accessDataDeliveries  AccessDataDelivery[]

  @@unique([streamingGroupId, userId])
}

model GroupJoinRequest {
  id                    String         @id @default(uuid())
  streamingGroup        StreamingGroup @relation(fields: [streamingGroupId], references: [id])
  streamingGroupId      String
  user                  User           @relation(fields: [userId], references: [id])
  userId                String
  status                JoinRequestStatus @default(PENDING)
  requestMessage        String?
  responseMessage       String?
  requestedAt           DateTime       @default(now())
  respondedAt           DateTime?
  respondedById         String?
  respondedBy           User?          @relation("GroupJoinRequestResponder", fields: [respondedById], references: [id])

  @@unique([streamingGroupId, userId])
}

enum StreamingGroupRole {
  OWNER
  ADMIN
  MEMBER
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AccessDataStatus {
  PENDING         // Aguardando envio dos dados pelo admin
  SENT            // Dados enviados pelo admin, aguardando confirmação
  CONFIRMED       // Membro confirmou recebimento e funcionamento
  OVERDUE         // Prazo de 24h expirado sem envio
}

model AccessDataDelivery {
  id                    String         @id @default(uuid())
  streamingGroupUser    StreamingGroupUser @relation(fields: [streamingGroupUserId], references: [id])
  streamingGroupUserId  String
  deliveryType          AccessDataDeliveryType
  content               String         // Dados de acesso ou mensagem de convite
  isInviteLink          Boolean        @default(false)
  sentAt                DateTime       @default(now())
  confirmedAt           DateTime?
  notes                 String?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
}

enum AccessDataDeliveryType {
  CREDENTIALS         // Login e senha
  INVITE_LINK        // Link de convite
  ACCOUNT_SHARING    // Compartilhamento de conta existente
  INSTRUCTIONS       // Instruções especiais
}

model Streaming {
  id                    String                @id @default(uuid())
  name                  String
  description           String?
  platform              String                
  logoUrl               String?
  websiteUrl            String?
  monthlyPrice          Float?
  maxUsers              Int                   @default(1)
  maxSimultaneousScreens Int                  @default(1) 
  isActive              Boolean               @default(true)
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  streamingGroupStreamings StreamingGroupStreaming[]
}

model StreamingGroupStreaming {
  id                    String         @id @default(uuid())
  streamingGroup        StreamingGroup @relation(fields: [streamingGroupId], references: [id])
  streamingGroupId      String
  streaming             Streaming      @relation(fields: [streamingId], references: [id])
  streamingId           String
  accountEmail          String
  accountPassword       String
  isAccountOwner        Boolean        @default(false)
  accountOwnerId        String?
  accountOwner          User?          @relation(fields: [accountOwnerId], references: [id])
  expiresAt             DateTime?
  isActive              Boolean        @default(true)
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  @@unique([streamingGroupId, streamingId])
}

model CreditTransaction {
  id                    String         @id @default(uuid())
  user                  User           @relation(fields: [userId], references: [id])
  userId                String
  type                  CreditTransactionType
  amount                Float
  description           String?
  paymentTransactionId  String?
  paymentTransaction    PaymentTransaction? @relation(fields: [paymentTransactionId], references: [id])
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
}

model PaymentTransaction {
  id                    String         @id @default(uuid())
  user                  User           @relation(fields: [userId], references: [id])
  userId                String
  orderNsu              String         @unique
  amount                Float          // Valor em centavos
  status                PaymentStatus  @default(PENDING)
  paymentMethod         String?
  transactionNsu        String?        // UUID da transação InfinitePay
  invoiceSlug           String?
  receiptUrl            String?
  infinitePayData       Json?          // Dados completos do webhook
  creditsAwarded        Float          @default(0)
  creditTransactions    CreditTransaction[]
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
}

enum CreditTransactionType {
  PURCHASE            // Compra de créditos
  SPEND               // Gasto de créditos
  REFUND              // Reembolso
  BONUS               // Bônus/promoção
  ADJUSTMENT          // Ajuste manual
}

enum PaymentStatus {
  PENDING             // Aguardando pagamento
  PAID                // Pago
  FAILED              // Falhou
  CANCELLED           // Cancelado
  REFUNDED            // Reembolsado
}
